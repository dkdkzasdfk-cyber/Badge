<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ù„Ø¹Ø¨Ø© Ø§Ù„Ù…ØºØ§Ù…Ø±Ø© Ø§Ù„ÙˆØ§Ù‚Ø¹ÙŠØ©</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        #instructions {
            position: absolute;
            top: 20px;
            right: 20px;
            color: white;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            border-radius: 5px;
            z-index: 100;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div id="instructions">
            <h3>ğŸ® ØªØ­ÙƒÙ… ÙÙŠ Ø§Ù„Ù„Ø¹Ø¨Ø©:</h3>
            <p>â†’ â† â†‘ â†“ : Ù„Ù„Ø­Ø±ÙƒØ©</p>
            <p>Ø²Ø± Ø§Ù„ÙØ£Ø±Ø©: Ø§Ù„Ù†Ø¸Ø± Ø­ÙˆÙ„Ùƒ</p>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/PointerLockControls.min.js"></script>
    <script>
        // Ø§Ù„Ù…ØªØºÙŠØ±Ø§Øª Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ©
        let scene, camera, renderer, controls;
        let player, terrain, birds = [];
        let clock = new THREE.Clock();
        let rain, rainGeo, rainCount = 15000;

        // ØªÙ‡ÙŠØ¦Ø© Ø§Ù„Ù…Ø´Ù‡Ø¯
        function init() {
            // Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù…Ø´Ù‡Ø¯
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x87CEEB, 50, 300);

            // Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 1.6, 0);

            // Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù…ÙØµÙŠÙÙ‘Ø±
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            document.getElementById('gameContainer').appendChild(renderer.domElement);

            // Ø¥Ø¶Ø§ÙØ© Ø§Ù„ØªØ­ÙƒÙ…
            controls = new THREE.PointerLockControls(camera, document.body);
            
            // Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ø¶ÙˆØ¡
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(50, 100, 50);
            directionalLight.castShadow = true;
            scene.add(directionalLight);

            // Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø£Ø±Ø¶ Ø§Ù„Ø¹Ø´Ø¨ÙŠØ©
            createTerrain();
            
            // Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø¬Ø¨Ø§Ù„
            createMountains();
            
            // Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù†Ù‡Ø±
            createRiver();
            
            // Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø´Ø®ØµÙŠØ©
            createPlayer();
            
            // Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø·ÙŠÙˆØ±
            createBirds();
            
            // Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ù…Ø·Ø±
            createRain();

            // Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ø³Ù…Ø§Ø¡
            const skybox = new THREE.Sky();
            skybox.scale.setScalar(450000);
            scene.add(skybox);

            const sun = new THREE.Vector3();
            const skyUniforms = skybox.material.uniforms;
            skyUniforms['sunPosition'].value = sun;

            // Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ø£Ø­Ø¯Ø§Ø«
            setupEventListeners();
            
            // Ø¨Ø¯Ø¡ Ø§Ù„Ù„Ø¹Ø¨Ø©
            animate();
        }

        function createTerrain() {
            const terrainGeometry = new THREE.PlaneGeometry(100, 100, 50, 50);
            const terrainMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x3a7e3a,
                wireframe: false
            });
            
            terrain = new THREE.Mesh(terrainGeometry, terrainMaterial);
            terrain.rotation.x = -Math.PI / 2;
            terrain.receiveShadow = true;
            
            // Ø¥Ø¶Ø§ÙØ© Ø¨Ø¹Ø¶ Ø§Ù„ØªØ¶Ø§Ø±ÙŠØ³ Ø§Ù„Ø·Ø¨ÙŠØ¹ÙŠØ©
            const positions = terrainGeometry.attributes.position.array;
            for (let i = 0; i < positions.length; i += 3) {
                positions[i + 2] = Math.random() * 0.5; // Ø§Ø±ØªÙØ§Ø¹ Ø¹Ø´ÙˆØ§Ø¦ÙŠ Ø¨Ø³ÙŠØ·
            }
            terrainGeometry.attributes.position.needsUpdate = true;
            
            scene.add(terrain);
        }

        function createMountains() {
            const mountainGroup = new THREE.Group();
            
            // Ø¥Ù†Ø´Ø§Ø¡ Ø¬Ø¨Ø§Ù„ Ø­ÙˆÙ„ Ø§Ù„Ø­Ø§ÙØ©
            for (let i = 0; i < 8; i++) {
                const angle = (i / 8) * Math.PI * 2;
                const radius = 45;
                const x = Math.cos(angle) * radius;
                const z = Math.sin(angle) * radius;
                
                const mountainGeometry = new THREE.ConeGeometry(8, 15 + Math.random() * 10, 8);
                const mountainMaterial = new THREE.MeshLambertMaterial({ 
                    color: 0x5d4037 
                });
                
                const mountain = new THREE.Mesh(mountainGeometry, mountainMaterial);
                mountain.position.set(x, 7.5, z);
                mountain.castShadow = true;
                
                mountainGroup.add(mountain);
            }
            
            scene.add(mountainGroup);
        }

        function createRiver() {
            const riverGeometry = new THREE.PlaneGeometry(10, 30);
            const riverMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x0077be,
                transparent: true,
                opacity: 0.8
            });
            
            const river = new THREE.Mesh(riverGeometry, riverMaterial);
            river.rotation.x = -Math.PI / 2;
            river.position.set(15, 0.1, 0);
            scene.add(river);
        }

        function createPlayer() {
            // Ø¬Ø³Ù… Ø§Ù„Ù„Ø§Ø¹Ø¨
            const bodyGeometry = new THREE.CapsuleGeometry(0.3, 1.2, 4, 8);
            const bodyMaterial = new THREE.MeshLambertMaterial({ color: 0x000000 });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            
            // Ø§Ù„Ø±Ø£Ø³
            const headGeometry = new THREE.SphereGeometry(0.25, 16, 16);
            const headMaterial = new THREE.MeshLambertMaterial({ color: 0xffffff });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.y = 0.8;
            
            // Ø§Ù„Ø®ÙˆØ°Ø©
            const helmetGeometry = new THREE.SphereGeometry(0.3, 16, 16);
            const helmetMaterial = new THREE.MeshLambertMaterial({ color: 0x00ff00 });
            const helmet = new THREE.Mesh(helmetGeometry, helmetMaterial);
            helmet.position.y = 0.8;
            helmet.scale.set(1, 0.8, 1);
            
            player = new THREE.Group();
            player.add(body);
            player.add(head);
            player.add(helmet);
            player.position.set(0, 0, 0);
            
            scene.add(player);
        }

        function createBirds() {
            for (let i = 0; i < 5; i++) {
                const birdGeometry = new THREE.SphereGeometry(0.1, 8, 8);
                const birdMaterial = new THREE.MeshLambertMaterial({ color: 0x000000 });
                const bird = new THREE.Mesh(birdGeometry, birdMaterial);
                
                bird.position.set(
                    Math.random() * 80 - 40,
                    10 + Math.random() * 10,
                    Math.random() * 80 - 40
                );
                
                birds.push({
                    mesh: bird,
                    speed: 0.5 + Math.random() * 0.5,
                    angle: Math.random() * Math.PI * 2
                });
                
                scene.add(bird);
            }
        }

        function createRain() {
            rainGeo = new THREE.BufferGeometry();
            const rainPositions = [];

            for (let i = 0; i < rainCount; i++) {
                rainPositions.push(
                    Math.random() * 100 - 50,
                    Math.random() * 50,
                    Math.random() * 100 - 50
                );
            }

            rainGeo.setAttribute('position', new THREE.Float32BufferAttribute(rainPositions, 3));
            
            const rainMaterial = new THREE.PointsMaterial({
                color: 0xaaaaaa,
                size: 0.1,
                transparent: true
            });

            rain = new THREE.Points(rainGeo, rainMaterial);
            scene.add(rain);
        }

        function setupEventListeners() {
            // Ø§Ù„ØªØ­ÙƒÙ… ÙÙŠ Ø§Ù„Ø­Ø±ÙƒØ©
            const moveState = {
                forward: false,
                backward: false,
                left: false,
                right: false
            };

            document.addEventListener('keydown', (event) => {
                switch (event.code) {
                    case 'ArrowUp':
                    case 'KeyW':
                        moveState.forward = true;
                        break;
                    case 'ArrowDown':
                    case 'KeyS':
                        moveState.backward = true;
                        break;
                    case 'ArrowLeft':
                    case 'KeyA':
                        moveState.left = true;
                        break;
                    case 'ArrowRight':
                    case 'KeyD':
                        moveState.right = true;
                        break;
                }
            });

            document.addEventListener('keyup', (event) => {
                switch (event.code) {
                    case 'ArrowUp':
                    case 'KeyW':
                        moveState.forward = false;
                        break;
                    case 'ArrowDown':
                    case 'KeyS':
                        moveState.backward = false;
                        break;
                    case 'ArrowLeft':
                    case 'KeyA':
                        moveState.left = false;
                        break;
                    case 'ArrowRight':
                    case 'KeyD':
                        moveState.right = false;
                        break;
                }
            });

            // ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø­Ø±ÙƒØ©
            function updateMovement() {
                const delta = clock.getDelta();
                const speed = 10 * delta;

                if (moveState.forward) {
                    controls.moveForward(speed);
                }
                if (moveState.backward) {
                    controls.moveForward(-speed);
                }
                if (moveState.left) {
                    controls.moveRight(-speed);
                }
                if (moveState.right) {
                    controls.moveRight(speed);
                }

                // ØªØ­Ø¯ÙŠØ« Ù…ÙˆØ¶Ø¹ Ø§Ù„Ø´Ø®ØµÙŠØ© Ø§Ù„Ù…Ø±Ø¦ÙŠØ©
                if (player) {
                    player.position.copy(camera.position);
                    player.position.y = 0;
                }
            }

            // Ø¥Ø¶Ø§ÙØ© ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø­Ø±ÙƒØ© Ù„Ù„Ø£Ù†ÙŠÙ…ÙŠØ´Ù†
            clock.start();
            setInterval(updateMovement, 16);
        }

        function animate() {
            requestAnimationFrame(animate);

            // ØªØ­Ø±ÙŠÙƒ Ø§Ù„Ø·ÙŠÙˆØ±
            birds.forEach(bird => {
                bird.angle += bird.speed * 0.01;
                bird.mesh.position.x += Math.cos(bird.angle) * 0.1;
                bird.mesh.position.z += Math.sin(bird.angle) * 0.1;
                bird.mesh.position.y += Math.sin(Date.now() * 0.001) * 0.05;
            });

            // ØªØ­Ø±ÙŠÙƒ Ø§Ù„Ù…Ø·Ø±
            if (rain) {
                const positions = rainGeo.attributes.position.array;
                for (let i = 1; i < positions.length; i += 3) {
                    positions[i] -= 0.2;
                    if (positions[i] < 0) {
                        positions[i] = 50;
                    }
                }
                rainGeo.attributes.position.needsUpdate = true;
            }

            renderer.render(scene, camera);
        }

        // Ø¨Ø¯Ø¡ Ø§Ù„Ù„Ø¹Ø¨Ø© Ø¹Ù†Ø¯ Ø§Ù„Ù†Ù‚Ø±
        document.addEventListener('click', () => {
            controls.lock();
        });

        // Ø§Ù„ØªØ¹Ø§Ù…Ù„ Ù…Ø¹ ØªØºÙŠÙŠØ± Ø­Ø¬Ù… Ø§Ù„Ù†Ø§ÙØ°Ø©
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // ØªØ´ØºÙŠÙ„ Ø§Ù„Ù„Ø¹Ø¨Ø©
        init();
    </script>
</body>
</html>